git init      # 初始化本地仓库, 会创建.git文件夹, .git是当前目录是否是仓库的标志
git add file  # 将file添加到git中, file的状态从untracked变为staged
git status    # 查看当前仓库的状态, 比如: 哪些文件是untracked(没有被追踪的, 即没有
    # 添加到git仓库的), 哪些是staged(可以被commited的), 哪些是之前add但是有修改过
git diff      # 查看文件修改的具体地方
git commit -m 'the description'  # 提交修改到仓库, 必须是有-m选项
git checkout -- file  # 如果修改了file或直接用系统命令删除了file, 则可以由此恢复
git log --pretty=oneline  # 查看commit的历史记录, HEAD是当前版本, 往下是时间越靠前
    # 的版本, 前面的16进制串是commit_id(版本号), 是一个哈希值
git reflog    # 可以查看命令历史, 确定每次提交的版本号, 从而用git reset恢复指定版
    # 本, 准确来说, git log查看提交历史便于回退到哪个版本, git reflog查看命令历史
    # 便于确定回到未来哪个版本
git reset --hard commit_id  # 用于回到指定版本, commit_id可以是hash的前几位, 只要
    # 能唯一确定版本号即可, HEAD是当前版本, HEAD^ HEAD^^分别是上一个和上上个版本
    # 以此类推, 也可以用HEAD~5表示最新的第5个版本
    # ps: git其实是用HEAD指针指向当前版本的, 如果直接退回到倒数第n个版本, 则这个
    #   版本就会成为新的HEAD, 而0~n-1这些则看不到了, 但是可以使用git reflog查看所
    #   有的commit_id序列, 从而找到之前的HEAD恢复, 此时log列表中可以看到所有的
    #   commit_id的, 0~n-1 n n+1等
    # ps: 使用这条命令时一定要特别注意, 如果有add后没有提交的文件, 必须要提交之后
    #   才reset, 否则即使再次恢复到改版本, 这些staged状态的文件都会丢失, 这一点很
    #   可怕的, 整个文件都没了

# git中文件的状态: 没有使用add的文件都是untracked状态, 表示不会被git追踪和管理, 如
    # 果使用了add, 则会被git追踪了, 此时状态分为两种:staged和unstaged, 前者是指可
    # 以直接commit的, 一般是刚用add之后的文件, 后者则是之前add了但是后面又修改了,
    # 此时需要将修改后的文件再次add, 才会变成staged状态

