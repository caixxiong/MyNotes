git init      # 初始化本地仓库, 会创建.git文件夹, .git是当前目录是否是仓库的标志
git add file  # 将file添加到git中, file的状态从untracked变为staged
git status    # 查看当前仓库的状态, 比如: 哪些文件是untracked(没有被追踪的, 即没有
    # 添加到git仓库的), 哪些是staged(可以被commited的), 哪些是之前add但是有修改过
git diff      # 查看文件修改的具体地方, git diff HEAD -- file 可以查看工作区和最新
    # 版本的file的区别
git commit -m 'the description'  # 提交修改到仓库, 必须是有-m选项
git checkout -- file  # 如果修改了file或直接用系统命令删除了file, 则可以由此恢复
git log --pretty=oneline  # 查看commit的历史记录, HEAD是当前版本, 往下是时间越靠前
    # 的版本, 前面的16进制串是commit_id(版本号), 是一个哈希值
git reflog    # 可以查看命令历史, 确定每次提交的版本号, 从而用git reset恢复指定版
    # 本, 准确来说, git log查看提交历史便于回退到哪个版本, git reflog查看命令历史
    # 便于确定回到未来哪个版本
git reset --hard commit_id  # 用于回到指定版本, commit_id可以是hash的前几位, 只要
    # 能唯一确定版本号即可, HEAD是当前版本, HEAD^ HEAD^^分别是上一个和上上个版本
    # 以此类推, 也可以用HEAD~5表示最新的第5个版本
    # ps: git其实是用HEAD指针指向当前版本的, 如果直接退回到倒数第n个版本, 则这个
    #   版本就会成为新的HEAD, 而0~n-1这些则看不到了, 但是可以使用git reflog查看所
    #   有的commit_id序列, 从而找到之前的HEAD恢复, 此时log列表中可以看到所有的
    #   commit_id的, 0~n-1 n n+1等
    # ps: 使用这条命令时一定要特别注意, 如果有add后没有提交的文件, 必须要提交之后
    #   才reset, 否则即使再次恢复到改版本, 这些staged状态的文件都会丢失, 这一点很
    #   可怕的, 整个文件都没了

# git中文件的状态: 没有使用add的文件都是untracked状态, 表示不会被git追踪和管理, 如
    # 果使用了add, 则会被git追踪了, 此时状态分为两种:staged和unstaged, 前者是指可
    # 以直接commit的, 一般是刚用add之后的文件, 后者则是之前add了但是后面又修改了,
    # 此时需要将修改后的文件再次add, 才会变成staged状态

# git概念: 
    # 工作区: 就是我们看到的当前目录的文件状态, 我们的所有改动都是在工作区
    # 暂存区: staged or index, 用于存放文件在add之后的状态
    # 版本库: 每次commit都会有一个版本号(comit_id), 它表示某次修改的所有文件的最终
    #         状态, 从comit_id可以恢复出一个版本的(所有)文件
    # ps: git管理的是文件的修改(状态), 而不是文件本身,只是在恢复的时候可以根据保存
    #     的这些修改状态和最初的文件还原最终的文件

# ps: git diff显示的信息含义:
    # 第一行: diff --git a/file_name b/file_name, 是git实际执行的命令, a是原文件
    #         b是修改后的文件
    # 第二行: index a964e37..e24a1f1 100644, 分别表示a和b的hash前7位, 100644是代
    #         表对象的模式(100644 普通文件&644权限)
    # 第三四行: 表示接下来进行比较的两个文件, 因为diff是可以同时比较多个文件的, 
    #         ---表示改动前的文件, +++是改动后的文件
    # @@ -n,m +k,j@@ 的含义: 首先git比较时会把当前改动位置的上下文内容显示出来,
    #         正常是前后各3行, 但是如果当前修改的位置没有足够的前后上下文内容, 
    #         则有多少显示多少行, 这时就需要根据颜色来区分有多少上下文行了, 上
    #         下文内容显示颜色是正常的, 改动的内容-是红色+是绿色.
    #         
    #         -n,m标志原文件的改动位置, +k,j标志修改后文件的改动位置, 其中n和k
    #         是指当前改动前上下文第1行的行号, 所以正常来说真正修改的第1行的行号
    #         是n+3(如果前面有3行上下文, 或者是n+0 1 2等), m, j则是表示包括上下
    #         文和修改的总行数, 所以git diff打印的信息是文件中的第n,.., n+m-1和
    #         k, .., k+j-1行. 显示的行中"-开头的红色字体"是原始内容, "+开头的绿
    #         色"是修改后的内容.注意, n和k不一定相同, 除非前面改动增删的行数相同
    #         
    #         @@ -2,7 +2,8@@ 分析: 8-7=1, 所以肯定是多了1行, 有可能是直接加一行
    #         也可能是修改了一行再加一行, 正常情况下7-3-3=1 是改动了文件的1行, 
    #         有时是上下文行数不足3+3, 则实际修改的行数就是m-上下文实际行数了
